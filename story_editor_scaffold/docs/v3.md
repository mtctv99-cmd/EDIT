# v3.md — Crop trực tiếp + Undo/Redo (nhúng trong `RowWidget`)

Tài liệu này hướng dẫn **thêm cơ chế Crop trực tiếp** (kéo–thả ngay trên ảnh, **không cần menu**) và **Undo/Redo** cho chỉnh sửa ảnh & văn bản. Mục tiêu: bật **Crop Mode** trên toolbar, người dùng **kéo chuột trên ảnh** để chọn vùng, **Enter** để xác nhận (thay ảnh), **Esc** để hủy, có **Undo/Redo** để quay lại/tiến tới các bước.

---

## 0) Phụ thuộc
```bash
pip install opencv-python numpy
```
- Crop dùng `cv2` để cắt ảnh theo tọa độ gốc nhằm **không mất chất lượng**.

---

## 1) Luồng tương tác

1. Bật **[✓] Crop Mode** trên toolbar (`MainWindow.chk_crop`).  
2. Ở mỗi `RowWidget`, **con trỏ chuột chuyển thành dấu cộng** khi hover lên ảnh: kéo–thả để tạo **khung crop** (rubber band).  
3. Thả chuột → hiển thị khung (điểm neo có thể kéo chỉnh).  
4. **Enter** → cắt ảnh theo khung → **thay ảnh của hàng**.  
5. **Esc** → hủy khung crop hiện tại (không thay ảnh).  
6. Mọi thay đổi (crop ảnh, thay ảnh, xóa ảnh, sửa text) **đẩy vào Undo stack** của `MainWindow` → **Ctrl+Z** (Undo), **Ctrl+Y** (Redo).

> Khi **Crop Mode tắt**, ảnh trở về trạng thái bình thường (không nhận thao tác crop).

---

## 2) Kiến trúc

- **`RowWidget`**: nhúng **CropWidget nhẹ** (logic vẽ overlay & rubber band) + các state:
  - `crop_active` (có khung crop chưa?)
  - `crop_rect` (QRect nâng dần theo kéo)
- **`MainWindow`**: giữ **global Undo/Redo stacks**, mỗi item là 1 “command” (áp dụng **Command pattern** đơn giản).

---

## 3) Undo/Redo – Command pattern nhẹ

### 3.1. Định nghĩa command
Một command chứa:
- `do()` – thi hành (đã áp dụng khi tạo)
- `undo()` – phục hồi
- `redo()` – thi hành lại

Ví dụ 2 command phổ biến:
- **CropImageCommand(row, old_path, new_path)**: thay ảnh `old_path` → `new_path`.
- **SetTextCommand(row, old_text, new_text)**: đổi text.

### 3.2. Stack quản lý
Trong `MainWindow`:
- `self.undo_stack: list[Command]`
- `self.redo_stack: list[Command]`
- Khi `push(cmd)`: xóa `redo_stack`, thêm `cmd` vào `undo_stack`.
- Undo: pop từ `undo_stack` → `undo()` → push sang `redo_stack`.
- Redo: pop từ `redo_stack` → `redo()` → push sang `undo_stack`.

> Với thao tác thay ảnh từ Crop, tạo file tạm **new_path** rồi push `CropImageCommand`.

---

## 4) Thay đổi trong mã

### 4.1. `main_window.py` – khai báo stack & phím tắt
- Khai báo:
```python
self.undo_stack = []
self.redo_stack = []
```
- Thêm **shortcut**:
```python
undo_act = QAction("Undo", self); undo_act.setShortcut("Ctrl+Z"); undo_act.triggered.connect(self._action_undo)
redo_act = QAction("Redo", self); redo_act.setShortcut("Ctrl+Y"); redo_act.triggered.connect(self._action_redo)
self.addAction(undo_act); self.addAction(redo_act)
```
- Handlers:
```python
def push_command(self, cmd):
    self.undo_stack.append(cmd)
    self.redo_stack.clear()

def _action_undo(self):
    if not self.undo_stack: return
    cmd = self.undo_stack.pop()
    cmd.undo()
    self.redo_stack.append(cmd)

def _action_redo(self):
    if not self.redo_stack: return
    cmd = self.redo_stack.pop()
    cmd.redo()
    self.undo_stack.append(cmd)
```

- **Command classes** (đặt cuối file hoặc `core/commands.py`):
```python
class CropImageCommand:
    def __init__(self, row, old_path, new_path):
        self.row = row
        self.old = old_path
        self.new = new_path
    def undo(self):
        self.row.set_image(self.old)
    def redo(self):
        self.row.set_image(self.new)
```

> Có thể bổ sung `SetTextCommand` tương tự nếu muốn Undo/Redo cho text.

### 4.2. Toolbar – Crop Mode
Đã có `self.chk_crop` trên toolbar. Trong `RowWidget`, đọc trạng thái bằng `self.host.chk_crop.isChecked()` (host = EditorScreen → MainWindow).

### 4.3. `ui/widgets.py` – thêm crop trực tiếp trong `RowWidget`
Thêm các thuộc tính & events:
```python
from PyQt5.QtCore import Qt, QRect, QPoint
import cv2, numpy as np, os, tempfile
from uuid import uuid4

class RowWidget(QWidget):
    def __init__(...):
        # ... đã có
        self._rubber_origin = None
        self._rubber_rect = None  # QRect khung crop hiện tại

        # cho ảnh nhận mouse events
        self.image_label.setMouseTracking(True)
        self.image_label.installEventFilter(self)  # chặn event tại label

    def eventFilter(self, obj, ev):
        if obj is self.image_label and self.host.host.chk_crop.isChecked():
            t = ev.type()
            if t == ev.MouseMove:
                self._on_crop_mouse_move(ev)
                return True
            elif t == ev.MouseButtonPress and ev.button() == Qt.LeftButton:
                self._on_crop_mouse_press(ev)
                return True
            elif t == ev.MouseButtonRelease and ev.button() == Qt.LeftButton:
                self._on_crop_mouse_release(ev)
                return True
            elif t == ev.KeyPress:
                # đề phòng focus: dùng keyPressEvent của RowWidget
                return False
        return super().eventFilter(obj, ev)

    def keyPressEvent(self, ev):
        if not self.host.host.chk_crop.isChecked():
            return super().keyPressEvent(ev)
        if ev.key() == Qt.Key_Escape:
            self._rubber_rect = None; self.update()
            return
        if ev.key() in (Qt.Key_Return, Qt.Key_Enter):
            self._commit_crop()
            return
        super().keyPressEvent(ev)

    def _on_crop_mouse_press(self, ev):
        if not self._image_path: return
        self.image_label.setFocus()
        self._rubber_origin = ev.pos()
        self._rubber_rect = QRect(self._rubber_origin, self._rubber_origin)
        self.update()

    def _on_crop_mouse_move(self, ev):
        if self._rubber_origin is None: return
        self._rubber_rect = QRect(self._rubber_origin, ev.pos()).normalized()
        self.update()

    def _on_crop_mouse_release(self, ev):
        if self._rubber_origin is None: return
        self._rubber_rect = QRect(self._rubber_origin, ev.pos()).normalized()
        self.update()
        # chờ Enter để xác nhận
        self._rubber_origin = None

    def paintEvent(self, e):
        super().paintEvent(e)
        # overlay vẽ khung trên image_label
        if self._rubber_rect and self.host.host.chk_crop.isChecked():
            # vẽ ở coordinate của RowWidget -> cần map sang image_label
            # đơn giản: vẽ 1 rect semi transparent đè lên label qua stylesheet? 
            # hoặc dùng QPainter toàn widget:
            from PyQt5.QtGui import QPainter, QPen, QColor
            p = QPainter(self)
            # translate vị trí label
            off = self.image_label.pos()
            r = self._rubber_rect.translated(off)
            p.setPen(QPen(QColor(0,200,0), 2))
            p.drawRect(r)

    def _commit_crop(self):
        if not (self._rubber_rect and self._image_path):
            return
        # Tính rect trên ảnh gốc bằng tỉ lệ giữa pixmap hiển thị & ảnh gốc
        label_pix = self.image_label.pixmap()
        if label_pix is None or label_pix.isNull():
            return
        # kích thước pixmap hiển thị
        disp_w, disp_h = label_pix.width(), label_pix.height()
        # vị trí của label trong RowWidget
        off = self.image_label.pos()
        rect = self._rubber_rect.translated(-off)
        # clamp vào pixmap
        x = max(0, min(disp_w-1, rect.x()))
        y = max(0, min(disp_h-1, rect.y()))
        w = max(1, min(disp_w-x, rect.width()))
        h = max(1, min(disp_h-y, rect.height()))

        img = cv2.imread(self._image_path)
        if img is None: return
        ih, iw = img.shape[:2]
        sx, sy = iw/disp_w, ih/disp_h

        gx0, gy0 = int(x*sx), int(y*sy)
        gx1, gy1 = int((x+w)*sx), int((y+h)*sy)
        gx0 = max(0, min(iw-1, gx0))
        gx1 = max(0, min(iw, gx1))
        gy0 = max(0, min(ih-1, gy0))
        gy1 = max(0, min(ih, gy1))
        if gx1-gx0 < 2 or gy1-gy0 < 2:
            self._rubber_rect = None; self.update(); return

        crop = img[gy0:gy1, gx0:gx1].copy()
        import tempfile
        from uuid import uuid4
        out_path = os.path.join(tempfile.gettempdir(), f"crop_{uuid4().hex}.png")
        cv2.imwrite(out_path, crop)

        # push command vào undo stack
        main = self.host.host  # MainWindow
        if hasattr(main, "push_command"):
            from types import SimpleNamespace
            cmd = SimpleNamespace(
                undo=lambda: self.set_image(self._image_path),
                redo=lambda: self.set_image(out_path)
            )
            # Lưu old_path trước khi đổi
            old_path = self._image_path
            self.set_image(out_path)
            # định nghĩa lại undo dùng old_path
            cmd.undo = lambda op=old_path: self.set_image(op)
            main.push_command(cmd)
        else:
            self.set_image(out_path)

        self._rubber_rect = None
        self.update()
```

> Đoạn trên là **khung triển khai**. Bạn có thể thay `SimpleNamespace` bằng class `CropImageCommand` để rõ ràng hơn (mục 3.2).

- **Chú ý**: `paintEvent` vẽ khung thẳng lên `RowWidget`. Nếu muốn overlay đẹp hơn (tô mờ ngoài vùng crop), bạn có thể mở rộng theo `crop.md` (mask/overlay).

---

## 5) Hành vi khi Crop Mode OFF
- Khi tắt checkbox **Crop Mode**, `eventFilter` không xử lý chuột nữa → menu chuột phải ảnh (Thay/Xóa…) vẫn hoạt động bình thường.

---

## 6) Mẹo & mở rộng
- **Giữ tỉ lệ** (ví dụ 16:9): khi kéo, nếu giữ **Shift** thì snap theo tỷ lệ cố định.
- **Hiển thị kích thước crop** (w×h px) cạnh khung.
- **Undo/Redo cho text**: lắng nghe `textChanged` và gom theo “nhịp” (debounce) để không tạo quá nhiều lệnh.
- **Lưu ảnh crop** vào thư mục của project thay vì `%TEMP%` nếu muốn bảo toàn đường dẫn khi mở lại.

---

## 7) Checklist
- [ ] Thêm import `cv2`, `numpy` và cài gói.  
- [ ] Bật/tắt **Crop Mode** với checkbox toolbar.  
- [ ] `RowWidget` xử lý chuột **trực tiếp** trên ảnh để kéo–thả crop.  
- [ ] Enter → xác nhận crop (ghi file tạm) → thay ảnh.  
- [ ] Esc → hủy khung crop.  
- [ ] Thêm **Undo/Redo** (Ctrl+Z / Ctrl+Y) cho thao tác crop và chỉnh sửa khác.

---

**Kết thúc v3** – Sau khi làm theo, bạn đã có trải nghiệm crop **trực tiếp**, nhanh chóng, có **Undo/Redo**, sẵn sàng cho quy trình kể chuyện với Gemini CLI.
